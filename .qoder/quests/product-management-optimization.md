# 企鹅工坊产品管理与功能优化设计方案

## 一、开源项目规范管理

### 1.1 版本控制规范优化

#### 当前问题分析
项目当前的 .gitignore 已有基础配置，但在开源项目管理上仍有改进空间。

#### Git 忽略规则优化

**应当提交的内容**
- 源代码（前端 React/TypeScript 代码，后端 Node.js 代码）
- 项目配置文件（package.json、tsconfig.json、vite.config.ts）
- 启动脚本（Install.bat、Start.bat、Stop.bat、start-mac.command）
- 文档文件（README.md、metadata.json）
- 目录结构占位文件（.gitkeep）

**不应提交的内容（需确保被忽略）**
- 依赖包目录（node_modules）
- 构建产物（dist、dist-ssr）
- 用户数据文件
  - data 目录下的所有 JSON 数据文件（creative_ideas.json、history.json、settings.json、desktop_items.json）
  - input 目录（用户上传的输入图片）
  - output 目录（AI 生成的输出图片）
  - creative_images 目录（创意库缩略图）
  - thumbnails 目录（图片缩略图缓存）
- 日志文件（*.log）
- 环境配置文件（.env、.env.*）
- 编辑器配置（.vscode、.idea、.DS_Store）
- 临时文件和缓存

**需要新增的忽略规则建议**
- 打包生成的可执行文件（*.exe、penguin-backend.exe）
- 系统临时文件（Thumbs.db、desktop.ini）
- 备份文件（*.bak、*.backup）
- 压缩文件（*.zip 如果用于导出）

#### 目录结构规范

**需保留的空目录结构（通过 .gitkeep）**
- data/（数据文件存放目录）
- input/（用户输入图片目录）
- output/（生成图片输出目录）
- creative_images/（创意库图片目录）
- thumbnails/（缩略图缓存目录）

这些目录虽然不包含用户数据，但需要在项目初始化时存在，以避免程序运行时因目录不存在而报错。

### 1.2 版本管理策略

#### 语义化版本号规范

**当前版本**
- 前端：1.0.3（package.json）
- 后端：1.0.0（backend-nodejs/package.json）

**版本号格式**：主版本号.次版本号.修订号（MAJOR.MINOR.PATCH）

**版本递增规则**
- 主版本号（MAJOR）：不兼容的 API 修改或重大架构变更
- 次版本号（MINOR）：向下兼容的功能性新增
- 修订号（PATCH）：向下兼容的问题修正

**版本发布流程建议**
- 每次发布前统一更新前后端版本号，保持一致性
- 在 README.md 中维护版本更新日志
- 使用 Git Tag 标记每个发布版本（如 v0.2.4）
- 创建 CHANGELOG.md 文件记录详细的版本变更历史

#### 分支管理策略

**主要分支**
- main/master：稳定发布分支，只包含经过测试的代码
- develop：开发主分支，用于集成各功能开发

**辅助分支**
- feature/*：功能开发分支（如 feature/container-folder、feature/image-operations）
- bugfix/*：问题修复分支
- release/*：版本发布准备分支

### 1.3 项目优化空间

#### 代码结构优化方向

**前端优化**
- 组件拆分：Desktop.tsx 文件过大（2175行），建议按功能拆分为多个子组件
  - DesktopItem 组件（单个桌面项目的渲染）
  - DesktopContextMenu 组件（右键菜单）
  - DesktopSelectionBox 组件（选框功能）
  - DesktopDragHandler 组件（拖拽逻辑）
- 状态管理：考虑引入轻量状态管理（如 Zustand）以简化 props 传递
- 工具函数提取：将 snapToGrid、findNearestFreePosition 等工具函数提取到独立模块

**后端优化**
- 数据持久化：当前使用 JSON 文件存储，可考虑引入 SQLite 以支持更复杂的查询需求
- 文件管理：添加图片清理机制（删除长期未使用的缓存图片）
- API 文档：添加 Swagger/OpenAPI 文档说明

#### 性能优化方向

**图片处理优化**
- 实现渐进式图片加载（先加载缩略图，后加载原图）
- 添加图片懒加载机制（viewport 外的图片延迟加载）
- 优化缩略图生成策略（支持批量生成、异步处理）

**桌面交互优化**
- 使用虚拟滚动技术处理大量桌面项目
- 优化拖拽性能（使用 requestAnimationFrame）
- 添加防抖和节流机制以减少频繁的状态更新

#### 用户体验优化

**功能增强**
- 添加撤销/重做功能（Ctrl+Z / Ctrl+Y）
- 支持键盘快捷键操作（Del 删除、Ctrl+A 全选、Ctrl+C/V 复制粘贴）
- 添加批量操作工具栏
- 支持桌面布局保存与切换（多工作空间）

**视觉优化**
- 添加过渡动画（项目移动、文件夹打开等）
- 优化深色模式下的视觉效果
- 支持自定义主题色

#### 安全性优化

**数据保护**
- API Key 的加密存储（当前存储在 settings.json 中，建议加密）
- 用户数据定期备份机制
- 防止路径遍历攻击（文件上传和访问时的路径验证）

**错误处理**
- 添加全局错误边界（React Error Boundary）
- 完善 API 请求失败的重试机制
- 添加操作日志记录

#### 文档完善

**需要补充的文档**
- API 接口文档（前后端接口规范）
- 开发者贡献指南（CONTRIBUTING.md）
- 部署指南（支持 Linux/macOS 的部署说明）
- 架构设计文档（系统架构、数据流、状态管理）
- 用户使用手册（详细功能说明和操作指南）

---

## 二、桌面容器分类功能设计

### 2.1 功能定位与目标

**核心需求**
在现有文件夹功能的基础上，增加灵活的容器（Container）功能，允许用户创建不同尺寸的容器来归纳和组织桌面上的图片，提供更多样化的分类管理方式。

**与文件夹的区别**
- 文件夹：进入式管理，双击后进入文件夹内部查看内容
- 容器：可视化分组，在桌面上直接显示内部的项目，作为视觉分组边界

### 2.2 容器尺寸规格

#### 预定义容器尺寸

基于当前网格系统（GRID_SIZE = 100px），定义以下四种容器尺寸：

| 尺寸规格 | 网格占用 | 像素尺寸（宽×高） | 可容纳项目数 | 适用场景 |
|---------|---------|-----------------|-------------|---------|
| 1×1 容器 | 1×1 格 | 100×100 px | 1 个 | 单图强调、快速分类 |
| 1×2 容器 | 1×2 格 | 100×200 px | 2 个（垂直排列） | 对比图、序列图 |
| 2×1 容器 | 2×1 格 | 200×100 px | 2 个（水平排列） | 横向对比、时间线 |
| 2×2 容器 | 2×2 格 | 200×200 px | 4 个（2×2 网格） | 主题集合、分组展示 |

#### 容器尺寸特性

**固定尺寸设计理由**
- 保持桌面网格对齐的一致性
- 简化容器与普通项目的碰撞检测逻辑
- 便于用户快速理解和操作

**未来扩展可能性**
- 3×3、4×4 等更大尺寸容器
- 自定义尺寸容器（通过拖拽边缘调整）

### 2.3 容器数据结构

#### 新增类型定义

在 types.ts 中新增容器类型：

**容器尺寸类型**
```
'1x1' | '1x2' | '2x1' | '2x2'
```

**容器项目接口**

核心属性：
- id：唯一标识符（字符串）
- type：类型标识，固定为 'container'
- name：容器名称（字符串，可编辑）
- position：桌面位置坐标（DesktopPosition 对象）
- size：容器尺寸规格（ContainerSizeType）
- itemIds：包含的项目 ID 列表（字符串数组）
- layout：容器内部布局方式（ContainerLayoutType）
- color：容器边框/背景颜色（可选，字符串）
- createdAt：创建时间戳（数字）
- updatedAt：最后更新时间戳（数字）

**容器布局方式**

支持的布局类型：
- 'grid'：网格布局（默认），项目按网格自动排列
- 'stack'：堆叠布局，项目重叠显示（只显示顶部项目的一部分）
- 'free'：自由布局，用户可在容器内自由拖动项目位置

### 2.4 容器交互设计

#### 创建容器

**创建入口**
- 右键菜单：在桌面空白处右键，显示"新建容器"子菜单，包含四种尺寸选项
- 快捷操作：选中多个图片后，右键显示"放入新容器"选项，自动选择合适尺寸

**创建流程**
1. 用户选择容器尺寸
2. 系统在鼠标位置或空闲位置创建容器
3. 容器默认名称为"容器 (尺寸)"，如"容器 (2×2)"
4. 容器创建后自动进入命名状态，用户可立即修改名称

**尺寸选择智能建议**
- 选中 1 个项目时，建议 1×1 容器
- 选中 2 个项目时，建议 1×2 或 2×1 容器
- 选中 3-4 个项目时，建议 2×2 容器
- 选中 5 个以上项目时，建议使用文件夹或堆叠

#### 拖放到容器

**拖放目标识别**
- 拖拽项目时，鼠标悬停在容器上方，容器显示高亮边框（视觉反馈）
- 高亮颜色根据容器可用空间状态显示：
  - 绿色边框：容器有空位，可以放入
  - 红色边框：容器已满，无法放入

**拖放放置逻辑**
- 释放鼠标时，如果容器有空位，项目自动添加到容器的 itemIds 列表
- 项目在容器内按照容器的 layout 方式自动排列
- 如果容器已满，操作无效，显示提示"容器已满"

**容量限制规则**
- 1×1 容器：最多 1 个项目
- 1×2 容器：最多 2 个项目
- 2×1 容器：最多 2 个项目
- 2×2 容器：最多 4 个项目

#### 从容器移出

**移出方式一：拖拽移出**
- 在容器内选中项目并拖拽到容器外
- 释放鼠标时，项目从容器的 itemIds 中移除，恢复为桌面顶级项目

**移出方式二：右键菜单**
- 在容器内选中项目，右键显示"移出容器"选项
- 点击后，项目移动到容器附近的空闲位置

**移出方式三：批量移出**
- 选中容器，右键显示"展开容器"选项
- 点击后，容器内所有项目移出到容器周围，容器可选择保留或删除

#### 容器视图模式

**单击容器**
- 单击容器边框或空白区域：选中容器（显示选中高亮）
- 单击容器内的项目：选中该项目（可直接操作）

**双击容器**
- 提供两种模式选择：
  - 模式一：展开容器（将容器内项目平铺到桌面）
  - 模式二：进入聚焦视图（类似文件夹，全屏显示容器内容）

**容器内导航**
- 如果采用聚焦视图模式，提供"返回桌面"按钮
- 支持在容器视图中对内部项目进行所有常规操作

#### 容器样式配置

**外观自定义**
- 边框颜色：用户可选择容器边框颜色（从预设色板选择）
- 背景透明度：容器背景可设置透明度（0-100%）
- 标题位置：容器名称可显示在顶部、底部或隐藏

**布局切换**
- 用户可在容器右键菜单中切换布局方式：
  - 网格布局：项目均匀排列
  - 堆叠布局：模拟卡片堆叠效果
  - 自由布局：手动调整项目位置

### 2.5 容器与其他功能的交互

#### 与文件夹的协同

**容器与文件夹的相互转换**
- 容器可转换为文件夹：右键容器选择"转为文件夹"，容器内容移入文件夹
- 文件夹可转换为容器：右键文件夹选择"转为容器"，选择目标尺寸（如内容超出容量则提示）

**容器内可以包含文件夹**
- 容器内可放置文件夹项目（占用一个容器位置）
- 双击容器内的文件夹可直接打开

#### 与堆叠的协同

**容器内可以包含堆叠**
- 堆叠可作为单个项目放入容器
- 在容器内双击堆叠可展开查看

**自动归类建议**
- 当用户在容器内放入多个同类图片时，系统建议"是否创建堆叠"

#### 搜索与筛选

**容器内容可被搜索**
- 搜索时，容器内的项目也参与搜索匹配
- 匹配的项目所在容器会高亮显示

**容器过滤**
- 支持按容器尺寸筛选（显示所有 2×2 容器）
- 支持按容器是否为空筛选

### 2.6 容器的存储与持久化

#### 数据存储位置

容器数据存储在 desktop_items.json 中，与现有的 image、folder、stack 类型项目一起存储。

#### 数据迁移兼容性

**向前兼容处理**
- 旧版本打开包含容器的数据时，容器被识别为 folder 类型（降级处理）
- 提示用户升级到新版本以使用容器功能

**向后兼容保证**
- 新版本可以正常读取不包含容器的旧数据
- 容器功能为增量功能，不影响现有功能

### 2.7 UI/UX 设计要点

#### 视觉设计原则

**容器边框样式**
- 使用虚线或双线边框与普通项目区分
- 边框宽度：2-3px，确保可见性
- 圆角：4-8px，保持柔和视觉

**容器内项目显示**
- 图标尺寸与普通桌面项目一致（80px）
- 保持适当内边距（8-12px）
- 项目名称可选择性显示（避免过于拥挤）

**容器标题栏**
- 位置：容器顶部或底部
- 内容：容器名称 + 项目计数（如"创意集 2/4"）
- 高度：24-32px
- 背景：半透明，与主题色协调

#### 交互反馈设计

**悬停状态**
- 鼠标悬停容器：边框颜色加深或发光效果
- 拖拽项目悬停容器：显示可放置状态（绿色高亮）或已满状态（红色高亮）

**选中状态**
- 选中容器：边框加粗，显示调整手柄（如未来支持尺寸调整）
- 选中容器内项目：项目高亮，容器边框保持常态

**拖拽状态**
- 拖拽容器：整个容器跟随鼠标移动，显示半透明预览
- 拖拽容器内项目：项目脱离容器，容器内显示空位占位符

#### 响应式适配

**小屏幕适配**
- 2×2 容器在小屏幕下可能显示拥挤，提供"缩放查看"选项
- 移动端可考虑容器自动展开为列表视图

**大屏幕优化**
- 支持更大的容器尺寸（3×3、4×4）
- 容器内项目可选择更大的图标尺寸

---

## 三、图片基础操作功能设计

### 3.1 功能定位与边界

**核心目标**
提供基础的图片处理能力，允许用户在不借助外部工具的情况下，对桌面上的图片进行简单的排版和调整操作，增强产品的自给自足性。

**功能边界明确**
- 这些操作均为非 AI 实现的传统图像处理功能
- 不涉及图像内容理解、智能裁剪、风格迁移等 AI 能力
- 使用现有的图像处理库（Sharp）实现

### 3.2 图片合并功能

#### 功能描述

**合并方向**
支持四个方向的图片拼接：
- 上下合并：图片 A 在上，图片 B 在下
- 左右合并：图片 A 在左，图片 B 在右
- 上下左右组合：支持 2×2、3×1、1×3 等多种布局的批量合并

**合并规则**

**尺寸处理策略**
- 对齐基准：
  - 左右合并时，以高度较大者为基准，较小图片垂直居中
  - 上下合并时，以宽度较大者为基准，较小图片水平居中
- 缩放选项：
  - 保持原尺寸（默认）：不缩放，留白填充
  - 拉伸对齐：较小图片拉伸至与较大图片对齐
  - 等比缩放：较大图片缩小至与较小图片匹配

**间距设置**
- 图片之间可添加间距（0-50px 可调）
- 间距颜色可自定义（白色、黑色、透明）

**背景填充**
- 当图片尺寸不一致且不拉伸时，空白区域填充颜色可选
- 默认填充颜色：白色
- 支持自定义填充颜色

#### 操作流程

**触发方式**
- 选中 2 个或多个图片项目
- 右键菜单显示"合并图片"选项，展开子菜单：
  - 左右合并
  - 上下合并
  - 自定义合并（打开配置弹窗）

**配置弹窗（自定义合并）**

弹窗内容：
- 布局选择器：可视化拖拽排列图片顺序和位置
- 尺寸处理选项：保持原尺寸 / 拉伸对齐 / 等比缩放
- 间距设置：滑块控制间距像素值
- 背景颜色：颜色选择器
- 预览区域：实时显示合并效果预览

操作按钮：
- 确认合并：执行合并操作
- 取消：关闭弹窗

**合并执行**
- 点击确认后，后端接收合并参数（图片路径列表、合并方向、尺寸策略、间距、背景色）
- 使用 Sharp 库进行图片合成
- 生成的新图片保存到 output 目录
- 在桌面上创建新的图片项目，位置在原图片附近
- 原图片保持不变（非破坏性操作）

#### 后端实现要点

**API 端点**
- POST /files/merge
- 请求参数：
  - imagePaths：待合并图片的路径数组（字符串数组）
  - layout：合并布局（'horizontal' | 'vertical' | 'grid'）
  - gridColumns：网格布局的列数（可选，默认 2）
  - resizeStrategy：尺寸处理策略（'keep' | 'stretch' | 'fit'）
  - spacing：图片间距（数字，单位 px）
  - backgroundColor：背景填充颜色（字符串，如 '#FFFFFF'）

**Sharp 处理流程**
1. 加载所有待合并图片，获取尺寸信息
2. 根据合并方向和尺寸策略，计算最终画布尺寸
3. 创建空白画布（Buffer）
4. 按顺序将每张图片合成到画布对应位置
5. 添加间距和背景填充
6. 输出最终合并图片，返回文件路径

**错误处理**
- 图片文件不存在：返回错误信息
- 图片格式不支持：返回错误信息
- 内存不足（图片过大）：返回错误信息并建议减少图片数量

### 3.3 图片裁切功能

#### 功能描述

**裁切类型**

**预设比例裁切**
- 提供常用裁切比例预设：
  - 1:1（正方形）
  - 4:3（标准照片）
  - 16:9（宽屏）
  - 3:2（经典照片）
  - 自定义比例

**自由裁切**
- 用户可拖拽裁切框的四个角和四条边
- 不限制裁切比例
- 显示实时裁切区域尺寸

**智能裁切建议**
- 根据图片内容分析，建议裁切区域（未来可接入 AI 能力）

#### 操作流程

**触发方式**
- 选中单个图片项目
- 右键菜单显示"裁切图片"选项
- 或双击图片后，在预览界面点击"裁切"按钮

**裁切界面**

界面布局：
- 中央区域：图片预览，叠加裁切框
- 左侧工具栏：
  - 预设比例按钮（1:1、4:3、16:9 等）
  - 自由裁切模式切换
  - 旋转按钮（90° 旋转）
  - 水平翻转、垂直翻转
- 底部信息栏：
  - 裁切区域尺寸显示（宽×高）
  - 裁切比例显示
- 右侧操作按钮：
  - 确认裁切
  - 取消

**裁切框交互**
- 拖拽角点：等比缩放裁切框（如锁定比例）或自由缩放
- 拖拽边：调整裁切框的宽度或高度
- 拖拽中央：移动裁切框位置
- 裁切框外区域：半透明遮罩（突出裁切区域）

**确认操作**
- 点击确认后，发送裁切参数到后端
- 后端使用 Sharp 的 extract 方法进行裁切
- 生成新图片，保存到 output 目录
- 在桌面上创建新图片项目，或替换原图片（可选）

#### 后端实现要点

**API 端点**
- POST /files/crop
- 请求参数：
  - imagePath：待裁切图片路径（字符串）
  - cropRegion：裁切区域（对象）
    - left：裁切区域左上角 X 坐标（数字）
    - top：裁切区域左上角 Y 坐标（数字）
    - width：裁切区域宽度（数字）
    - height：裁切区域高度（数字）

**Sharp 处理流程**
1. 加载原始图片
2. 验证裁切区域是否在图片范围内
3. 使用 sharp.extract() 方法裁切图片
4. 输出裁切后的图片，返回文件路径

**错误处理**
- 裁切区域超出图片范围：返回错误信息
- 图片文件不存在：返回错误信息

### 3.4 图片比例变化功能

#### 功能描述

**变化类型**

**等比缩放**
- 指定目标宽度，高度自动等比计算
- 指定目标高度，宽度自动等比计算
- 指定缩放比例（如 50%、200%）

**非等比拉伸**
- 同时指定目标宽度和高度
- 图片拉伸或压缩至指定尺寸（可能导致变形）

**智能缩放**
- 指定最大宽度或高度，图片在不超过限制的前提下等比缩放
- 适用于批量处理时统一图片尺寸

#### 操作流程

**触发方式**
- 选中单个或多个图片项目
- 右键菜单显示"调整尺寸"选项
- 打开尺寸调整弹窗

**尺寸调整弹窗**

弹窗内容：
- 当前尺寸显示：显示原图片的宽×高
- 目标尺寸设置：
  - 宽度输入框（数字，单位 px）
  - 高度输入框（数字，单位 px）
  - 锁定比例开关（默认开启）
  - 百分比缩放滑块（10%-500%）
- 缩放模式选择：
  - 等比缩放（默认）
  - 拉伸至指定尺寸
  - 适应最大尺寸（保持比例）
- 预览区域：显示缩放后的效果预览

操作按钮：
- 确认：执行尺寸调整
- 重置：恢复到原始尺寸
- 取消：关闭弹窗

**批量处理**
- 当选中多个图片时，所有图片应用相同的尺寸调整参数
- 提示用户确认批量操作

**确认操作**
- 点击确认后，发送缩放参数到后端
- 后端使用 Sharp 的 resize 方法进行缩放
- 生成新图片，保存到 output 目录
- 在桌面上创建新图片项目，或替换原图片（可选）

#### 后端实现要点

**API 端点**
- POST /files/resize
- 请求参数：
  - imagePath：待缩放图片路径（字符串，单图）或路径数组（批量）
  - width：目标宽度（数字，可选）
  - height：目标高度（数字，可选）
  - fit：缩放模式（'contain' | 'cover' | 'fill' | 'inside' | 'outside'）
  - maintainAspectRatio：是否保持宽高比（布尔值）

**Sharp 处理流程**
1. 加载原始图片
2. 根据参数调用 sharp.resize() 方法
3. 如果保持宽高比，使用 fit: 'inside' 模式
4. 如果拉伸，使用 fit: 'fill' 模式
5. 输出调整后的图片，返回文件路径

**错误处理**
- 目标尺寸无效（小于 1px 或超大尺寸）：返回错误信息
- 图片文件不存在：返回错误信息

### 3.5 附加功能建议

#### 图片旋转与翻转

**旋转功能**
- 支持 90°、180°、270° 旋转
- 在裁切界面或独立操作中提供

**翻转功能**
- 水平翻转（镜像）
- 垂直翻转（上下颠倒）

**实现方式**
- Sharp 的 rotate() 和 flip()/flop() 方法

#### 图片格式转换

**格式支持**
- 输入格式：JPEG、PNG、WebP、GIF（静态）
- 输出格式：JPEG、PNG、WebP

**转换选项**
- 质量设置（JPEG/WebP）：1-100
- 是否保留透明度（PNG/WebP）

#### 批量操作优化

**操作队列**
- 当批量处理多个图片时，显示操作进度条
- 支持取消队列中的操作

**预设方案保存**
- 用户可保存常用的合并/裁切/缩放配置
- 下次操作时快速应用预设

### 3.6 UI/UX 设计要点

#### 操作界面一致性

**统一的编辑工具栏**
- 所有图片编辑操作（合并、裁切、缩放）共享统一的界面风格
- 工具栏位置固定（顶部或侧边）
- 操作按钮图标直观易懂

#### 非破坏性编辑原则

**保留原图**
- 所有编辑操作默认生成新图片，不覆盖原图
- 提供"替换原图"选项（需用户明确确认）

**操作记录**
- 在图片项目上显示"已编辑"标记
- 可查看编辑历史（如"由 image1.jpg 和 image2.jpg 合并而来"）

#### 性能与体验优化

**实时预览**
- 裁切框移动和缩放时，实时更新预览
- 使用防抖技术减少渲染次数

**大图片处理**
- 对于超大图片（如 4K 以上），裁切和缩放界面使用缩略图预览
- 实际操作在后端处理原图

**操作反馈**
- 图片处理中显示 loading 状态
- 处理完成后显示成功提示和新图片位置

---

## 四、实施优先级建议

### 第一阶段：开源规范完善（优先级：高）

**时间估算**：1-2 周

**工作内容**
- 完善 .gitignore 规则
- 统一前后端版本号
- 创建 CHANGELOG.md 和 CONTRIBUTING.md
- 优化 README.md（添加徽章、详细安装步骤、常见问题）

**交付物**
- 规范的版本控制配置
- 完善的项目文档
- 清晰的开源项目结构

### 第二阶段：容器功能开发（优先级：中）

**时间估算**：3-4 周

**工作内容**
- 定义容器数据类型和接口
- 实现容器的创建、删除、编辑功能
- 实现容器与项目的拖拽交互
- 实现容器的视觉样式和布局逻辑
- 添加容器相关的右键菜单选项

**交付物**
- 完整的容器功能模块
- 容器功能的用户文档

### 第三阶段：图片基础操作功能（优先级：中）

**时间估算**：2-3 周

**工作内容**
- 后端实现图片合并 API
- 后端实现图片裁切 API
- 后端实现图片缩放 API
- 前端实现合并、裁切、缩放的操作界面
- 添加操作结果的桌面显示逻辑

**交付物**
- 图片合并、裁切、缩放功能
- 图片操作功能的用户文档

### 第四阶段：性能与体验优化（优先级：低）

**时间估算**：持续优化

**工作内容**
- 代码重构（拆分大型组件）
- 性能优化（图片懒加载、虚拟滚动）
- 添加快捷键支持
- 添加撤销/重做功能
- 完善错误处理和日志记录

**交付物**
- 更流畅的用户体验
- 更健壮的系统稳定性

---

## 五、技术实现关键点

### 5.1 容器功能技术要点

#### 前端实现

**位置计算**
- 容器占用多个网格单元，需要特殊的碰撞检测逻辑
- 检查容器与其他项目的重叠时，需判断容器的矩形区域

**渲染优化**
- 容器内的项目作为子元素渲染
- 使用 CSS Grid 或 Flexbox 实现容器内部布局

**拖拽处理**
- 区分拖拽容器整体和拖拽容器内的单个项目
- 拖拽目标识别时，判断鼠标位置是否在容器的边界内

#### 后端存储

**数据一致性**
- 容器的 itemIds 与实际项目的 ID 保持同步
- 删除项目时，需同时更新容器的 itemIds

**数据迁移**
- 提供数据迁移脚本，将旧数据格式升级到支持容器的新格式

### 5.2 图片操作技术要点

#### Sharp 库使用

**图片合并**
```
使用 sharp 的 composite 方法实现图片叠加合成
```

**图片裁切**
```
使用 sharp 的 extract 方法提取指定区域
```

**图片缩放**
```
使用 sharp 的 resize 方法调整尺寸
```

#### 文件管理

**文件命名规则**
- 合并后的图片：merged_[timestamp].jpg
- 裁切后的图片：cropped_[original_name]_[timestamp].jpg
- 缩放后的图片：resized_[original_name]_[timestamp].jpg

**缓存清理**
- 定期清理 output 目录中长期未访问的图片
- 提供手动清理缓存的功能

#### API 设计

**请求参数验证**
- 验证图片路径是否在允许的目录内（防止路径遍历攻击）
- 验证图片文件是否存在
- 验证尺寸参数是否合法

**响应格式统一**
```
成功响应：{ success: true, data: { imageUrl, width, height } }
错误响应：{ success: false, error: '错误信息' }
```

### 5.3 兼容性与扩展性

#### 向前兼容

**数据格式兼容**
- 新增的功能不影响现有数据结构
- 旧版本客户端打开新版本数据时，忽略不认识的字段

#### 扩展性设计

**容器功能扩展**
- 预留容器尺寸的扩展空间（如 3×3、4×4）
- 预留容器类型的扩展（如画板容器、时间线容器）

**图片操作扩展**
- 预留更多图片处理功能的接口（如滤镜、水印）
- 设计插件化架构，支持第三方图片处理插件

---

## 六、风险评估与应对

### 6.1 开发风险

**风险一：功能复杂度增加导致开发周期延长**
- 应对：分阶段实施，优先完成核心功能，附加功能后续迭代

**风险二：容器功能与现有文件夹功能冲突**
- 应对：明确两者定位区别，提供用户引导和迁移工具

**风险三：图片处理性能问题（大图片或批量操作）**
- 应对：使用任务队列、限制并发数、提供操作进度反馈

### 6.2 用户体验风险

**风险一：新功能学习成本高，用户不知如何使用**
- 应对：提供新手引导、操作提示、视频教程

**风险二：功能过多导致界面复杂，影响易用性**
- 应对：保持界面简洁，高级功能收纳在菜单或设置中

### 6.3 技术风险

**风险一：Sharp 库在不同系统上的兼容性问题**
- 应对：充分测试 Windows/macOS/Linux 环境，提供降级方案

**风险二：图片处理消耗大量内存或 CPU**
- 应对：限制单次处理的图片数量和尺寸，提供后台处理选项

---

## 七、成功标准

### 7.1 开源规范成功标准

- 项目在 GitHub 上获得至少 100 Star（3 个月内）
- 至少有 3 位外部贡献者提交 Pull Request
- 文档完整，用户可以无障碍地安装和使用
- 版本发布流程规范，无重大 Bug 回退

### 7.2 容器功能成功标准

- 用户可以顺畅创建四种尺寸的容器
- 容器内项目的拖放操作响应时间 < 100ms
- 容器功能使用率达到 30%（使用容器的用户占比）
- 用户反馈满意度 ≥ 4 分（5 分制）

### 7.3 图片操作功能成功标准

- 图片合并成功率 > 99%
- 图片裁切和缩放操作响应时间 < 2 秒（常规尺寸图片）
- 批量操作支持一次处理至少 10 张图片
- 用户反馈满意度 ≥ 4 分（5 分制）
